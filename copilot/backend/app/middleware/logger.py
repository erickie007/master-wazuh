from fastapi import HTTPException
from fastapi import Request
from fastapi.responses import JSONResponse
from sqlalchemy.ext.asyncio import AsyncSession

from app.auth.utils import AuthHandler
from app.db.db_session import async_engine
from app.utils import Logger

EXCLUDED_PATHS = ["/auth/token", "/auth/register"]
INTERNAL_SERVER_ERROR = 500


async def process_request(request: Request, call_next, session, logger_instance):
    """
    Process the incoming request and log the user ID.

    Args:
        request (Request): The incoming request.
        call_next (Callable): The next middleware or endpoint to call.
        session: The session object.
        logger_instance: The logger instance.

    Returns:
        Tuple: A tuple containing the response and the user ID.
    """
    response = await call_next(request)
    user_id = await logger_instance.get_user_id_from_request(request)
    return response, user_id


def is_excluded_path(path: str) -> bool:
    """
    Check if the given path is in the list of excluded paths.

    Args:
        path (str): The path to check.

    Returns:
        bool: True if the path is in the excluded paths list, False otherwise.
    """
    return path in EXCLUDED_PATHS


async def handle_exception(e, user_id, request, logger_instance):
    """
    Handles exceptions that occur during request processing.

    Args:
        e (Exception): The exception that occurred.
        user_id (int): The ID of the user associated with the request.
        request (Request): The request object.
        logger_instance (Logger): An instance of the logger.

    Returns:
        JSONResponse: The response containing the error message.
    """
    try:
        user_id = await logger_instance.get_user_id_from_request(request) if user_id is None else user_id
    except HTTPException as http_exc:
        return JSONResponse(
            status_code=http_exc.status_code,
            content={"message": str(http_exc), "success": False},
        )
    await logger_instance.log_error(user_id, request, e)
    status_code = e.status_code if isinstance(e, HTTPException) else INTERNAL_SERVER_ERROR
    return JSONResponse(
        status_code=status_code,
        content={"message": str(e), "success": False},
    )


async def log_requests(request: Request, call_next):
    """
    Middleware function to log incoming requests and their responses.

    Args:
        request (Request): The incoming request object.
        call_next (Callable): The next middleware or endpoint to call.

    Returns:
        The response generated by the next middleware or endpoint.
    """
    if request.method == "OPTIONS":
        return await call_next(request)

    async with AsyncSession(async_engine) as session:
        logger_instance = Logger(session, AuthHandler())
        user_id = None

        try:
            if not is_excluded_path(request.url.path):
                response, user_id = await process_request(
                    request,
                    call_next,
                    session,
                    logger_instance,
                )
            else:
                response = await call_next(request)
        except Exception as e:
            return await handle_exception(e, user_id, request, logger_instance)

        await logger_instance.log_route_access(user_id, request, response)

    return response
